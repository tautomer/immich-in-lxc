name: Build Immich Dependencies

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Immich release tag'
        required: true

jobs:
  Build-dependencies:
    runs-on: ubuntu-latest
    steps:
      - name: Install dependencies
        run: |
          sudo apt update
          packages=(
            jq
            curl
            git
            autoconf
            build-essential
            cmake
            libbrotli-dev
            libde265-dev
            libexif-dev
            libexpat1-dev
            libglib2.0-dev
            libgsf-1-dev
            liblcms2-2
            libspng-dev
            librsvg2-dev
            meson
            ninja-build
            pkg-config
            wget
            zlib1g
            libltdl-dev
            cpanminus
            libtool
            liblcms2-dev
            libgif-dev
            libpango1.0-dev
            libdav1d-dev
            libhwy-dev
            libwebp-dev
            libio-compress-brotli-perl
            libaom-dev
          )

          for pkg in "${packages[@]}"; do
            echo "Installing $pkg..."
            sudo apt install --no-install-recommends -yqq "$pkg"
          done

      - name: Download previous dependencies for latest release
        id: download_from_release
        run: |
          # We will try to restore the dependencies built from the latest (last) release
          # Then check if there is any update in the new release
          # The file is expected to be named dependencies.tar.gz
          # containing dummy deps/usr folder with all the dependencies and a deps/json folder saving the versions of the dependencies
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/latest/download/dependencies.tar.gz"
          # The `|| true` prevents the step from failing if the download URL returns a 404,
          # allowing us to handle the error gracefully.
          curl -L -s -f -o dependencies.tar.gz "$DOWNLOAD_URL" || true
    
          # Check if the file was successfully downloaded
          if [ -f "dependencies.tar.gz" ]; then
            echo "Previous artifact found and downloaded."
            echo "PREVIOUS_ARTIFACT_FOUND=true" >> "$GITHUB_ENV"
          else
            echo "No previous artifact found or download failed. Proceeding with full build."
            echo "PREVIOUS_ARTIFACT_FOUND=false" >> "$GITHUB_ENV"
          fi

      - name: Prepare build environment
        id: prepare_build
        run: |
          # Create the dependency folders
          mkdir -p "$HOME/deps/stow"
          mkdir -p "$HOME/deps/json"

          # Unpack old artifact if it exists
          if [ "$PREVIOUS_ARTIFACT_FOUND" = "true" ]; then
            echo "Unpacking previous artifact..."
            tar -xzf dependencies.tar.gz -C "$HOME"
            echo "build_all=false" >> $GITHUB_ENV
            for lib in $(ls -d ${HOME}/deps/stow/*/); do
              echo "Merging $lib..."
              sudo rsync -a "$lib" /usr/local/
            done
            sudo ldconfig
          else
            echo "No previous artifact found. All packages will be built."
            echo "build_all=true" >> $GITHUB_ENV
          fi

      - name: Find base-image commit
        id: find_commit
        run: |
          IMMICH_VERSION=${{ github.event.inputs.version }}
          # get the Dockerfile content from GitHub API and parse the base image tag
          BASE_IMAGE_TAG=$(curl -sL \
            -H "Accept: application/vnd.github.v3.raw" \
            "https://api.github.com/repos/immich-app/immich/contents/server/Dockerfile?ref=${IMMICH_VERSION}" | \
            grep 'FROM ghcr.io/immich-app/base-server-dev:' | \
            awk -F'[:@]' '{print $2}')

          echo "Found base image tag: $BASE_IMAGE_TAG"

          # use the GitHub Releases API to find the commit SHA for that tag
          COMMIT_SHA=$(curl -sL \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/immich-app/base-images/releases/tags/$BASE_IMAGE_TAG" | \
            jq -r '.target_commitish')

          echo "Found commit SHA: $COMMIT_SHA"

          # set the output for subsequent steps to use
          echo "base_commit=${COMMIT_SHA}" >> "$GITHUB_ENV"

      - name: Checkout base-images repo
        uses: actions/checkout@v4
        with:
          repository: immich-app/base-images
          ref: ${{ env.base_commit }}
          path: ./base-images

      - name: Create build-lock.json
        run: |
          cd base-images/server/

          # From base-images/server/Dockerfile line 110
          jq -s '.' packages/*.json > /tmp/packages.json
          jq -s '.' sources/*.json > /tmp/sources.json
          jq -n \
              --slurpfile sources /tmp/sources.json \
              --slurpfile packages /tmp/packages.json \
              '{sources: $sources[0], packages: $packages[0]}' \
              > $HOME/deps/json/build-lock.json

      - name: Modify build scripts
        run: |
          cd base-images/server/sources
          # modify the scripts
          # autoreconf behaves differently in GitHub runner
          sed -i "/autoreconf --install/i sed -i '1iAC_CONFIG_AUX_DIR([.])' configure.ac" libraw.sh
          # install to a custom location so we can repack it later and install with stow
          # libjxl to $HOME/deps/stow/libjxl
          sed -i 's#^ *cmake --install \.#&\nDESTDIR='"$HOME"'/deps/stow/libjxl & --prefix=/usr/local#' libjxl.sh
          # libheif to $HOME/deps/stow/libheif
          sed -i 's#^ *make -j"$(nproc)" install#&\n& DESTDIR='"$HOME"'/deps/stow/libheif#' libheif.sh
          # libraw to $HOME/deps/stow/libraw
          sed -i 's#^ *make install#&\n& DESTDIR='"$HOME"'/deps/stow/libraw#' libraw.sh
          # imagemagick to $HOME/deps/stow/imagemagick
          # version number is omitted here, but $HOME/deps/imagemagick/usr/local/lib/imagemagick-x.y.z is kept
          sed -i 's#^ *make install#&\n& DESTDIR='"$HOME"'/deps/stow/imagemagick#' imagemagick.sh
          # libvips to $HOME/deps/stow/libvips
          sed -i 's#^ *ninja install#&\nexport DESTDIR='"$HOME"'/deps/stow/libvips\n&#g' libvips.sh

      - name: Build Dependencies
        id: build_packages
        run: |
          BUILD_ALL=${{ env.build_all }}
          REPACK_NEEDED=false
          LIBRARIES=("libjxl" "libheif" "libraw" "imagemagick" "libvips")

          cd base-images/server/sources
          # build as needed
          for package_name in "${LIBRARIES[@]}"; do
            json_file="${package_name}.json"
            sh_file="${package_name}.sh"
            
            current_rev=$(jq -r '.revision' "$json_file")
            previous_rev=$(jq -r '.revision' "$HOME/deps/json/$json_file" 2>/dev/null || echo "")
            
            if [ "$BUILD_ALL" = "true" ] || [ "$current_rev" != "$previous_rev" ]; then
              echo "Building package: $package_name (current: $current_rev, previous: $previous_rev)"
              STOW_PKG_DIR="${HOME}/deps/stow/$package_name"
              rm -rf "$STOW_PKG_DIR"
              mkdir -p "$STOW_PKG_DIR"
              chmod u+x "$sh_file"
              sudo ./"$sh_file"
              NESTED_DIR="$STOW_PKG_DIR/usr/local"
              if [ -d "$NESTED_DIR" ]; then  
                shopt -s dotglob
                mv "$NESTED_DIR"/* "$STOW_PKG_DIR/"
                shopt -u dotglob
                rm -rf "$STOW_PKG_DIR/usr"
              fi
              cp "$json_file" "$HOME/deps/json/"
              REPACK_NEEDED=true
            else
              echo "Skipping package: $package_name (revision unchanged)"
            fi
          done

          echo "REPACK_NEEDED=$REPACK_NEEDED" >> "$GITHUB_OUTPUT"
          
      - name: Archive dependencies
        run: |
          REPACK_NEEDED="${{ steps.build_packages.outputs.REPACK_NEEDED }}"
          if [ "$REPACK_NEEDED" = "true" ]; then
            echo "Archiving dependencies..."
            tar -czf dependencies.tar.gz -C "$HOME" deps
          fi

      - name: Upload dependencies artifact
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: dependencies
          path: dependencies.tar.gz